// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pfs/pfs.proto

/*
	Package pfs is a generated protocol buffer package.

	It is generated from these files:
		client/pfs/pfs.proto

	It has these top-level messages:
		Repo
		Commit
		Commits
		BranchInfo
		BranchInfos
		File
		Block
		Object
		Tag
		RepoInfo
		RepoInfos
		CommitInfo
		CommitInfos
		FileInfo
		FileInfos
		ByteRange
		BlockRef
		ObjectInfo
		CreateRepoRequest
		InspectRepoRequest
		ListRepoRequest
		DeleteRepoRequest
		StartCommitRequest
		BuildCommitRequest
		FinishCommitRequest
		InspectCommitRequest
		ListCommitRequest
		ListBranchRequest
		SetBranchRequest
		DeleteBranchRequest
		DeleteCommitRequest
		FlushCommitRequest
		SubscribeCommitRequest
		GetFileRequest
		PutFileRequest
		InspectFileRequest
		ListFileRequest
		GlobFileRequest
		DiffFileRequest
		DiffFileResponse
		DeleteFileRequest
		PutObjectRequest
		GetObjectsRequest
		TagObjectRequest
		ListObjectsRequest
		ListTagsRequest
		ListTagsResponse
		DeleteObjectsRequest
		DeleteObjectsResponse
		DeleteTagsRequest
		DeleteTagsResponse
		CheckObjectRequest
		CheckObjectResponse
		ObjectIndex
*/
package pfs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FileType int32

const (
	FileType_RESERVED FileType = 0
	FileType_FILE     FileType = 1
	FileType_DIR      FileType = 2
)

var FileType_name = map[int32]string{
	0: "RESERVED",
	1: "FILE",
	2: "DIR",
}
var FileType_value = map[string]int32{
	"RESERVED": 0,
	"FILE":     1,
	"DIR":      2,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}
func (FileType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPfs, []int{0} }

type Delimiter int32

const (
	Delimiter_NONE Delimiter = 0
	Delimiter_JSON Delimiter = 1
	Delimiter_LINE Delimiter = 2
)

var Delimiter_name = map[int32]string{
	0: "NONE",
	1: "JSON",
	2: "LINE",
}
var Delimiter_value = map[string]int32{
	"NONE": 0,
	"JSON": 1,
	"LINE": 2,
}

func (x Delimiter) String() string {
	return proto.EnumName(Delimiter_name, int32(x))
}
func (Delimiter) EnumDescriptor() ([]byte, []int) { return fileDescriptorPfs, []int{1} }

type ListFileMode int32

const (
	ListFileMode_ListFile_NORMAL  ListFileMode = 0
	ListFileMode_ListFile_FAST    ListFileMode = 1
	ListFileMode_ListFile_RECURSE ListFileMode = 2
)

var ListFileMode_name = map[int32]string{
	0: "ListFile_NORMAL",
	1: "ListFile_FAST",
	2: "ListFile_RECURSE",
}
var ListFileMode_value = map[string]int32{
	"ListFile_NORMAL":  0,
	"ListFile_FAST":    1,
	"ListFile_RECURSE": 2,
}

func (x ListFileMode) String() string {
	return proto.EnumName(ListFileMode_name, int32(x))
}
func (ListFileMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorPfs, []int{2} }

type Repo struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Repo) Reset()                    { *m = Repo{} }
func (m *Repo) String() string            { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()               {}
func (*Repo) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{0} }

func (m *Repo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Commit struct {
	Repo *Repo  `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	ID   string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{1} }

func (m *Commit) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Commit) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type Commits struct {
	Commit []*Commit `protobuf:"bytes,1,rep,name=commit" json:"commit,omitempty"`
}

func (m *Commits) Reset()                    { *m = Commits{} }
func (m *Commits) String() string            { return proto.CompactTextString(m) }
func (*Commits) ProtoMessage()               {}
func (*Commits) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{2} }

func (m *Commits) GetCommit() []*Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type BranchInfo struct {
	Name string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Head *Commit `protobuf:"bytes,2,opt,name=head" json:"head,omitempty"`
}

func (m *BranchInfo) Reset()                    { *m = BranchInfo{} }
func (m *BranchInfo) String() string            { return proto.CompactTextString(m) }
func (*BranchInfo) ProtoMessage()               {}
func (*BranchInfo) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{3} }

func (m *BranchInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BranchInfo) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

type BranchInfos struct {
	BranchInfo []*BranchInfo `protobuf:"bytes,1,rep,name=branch_info,json=branchInfo" json:"branch_info,omitempty"`
}

func (m *BranchInfos) Reset()                    { *m = BranchInfos{} }
func (m *BranchInfos) String() string            { return proto.CompactTextString(m) }
func (*BranchInfos) ProtoMessage()               {}
func (*BranchInfos) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{4} }

func (m *BranchInfos) GetBranchInfo() []*BranchInfo {
	if m != nil {
		return m.BranchInfo
	}
	return nil
}

type File struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	Path   string  `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{5} }

func (m *File) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type Block struct {
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{6} }

func (m *Block) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Object struct {
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Object) Reset()                    { *m = Object{} }
func (m *Object) String() string            { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()               {}
func (*Object) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{7} }

func (m *Object) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type Tag struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{8} }

func (m *Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type RepoInfo struct {
	Repo        *Repo                       `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Created     *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=created" json:"created,omitempty"`
	SizeBytes   uint64                      `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Provenance  []*Repo                     `protobuf:"bytes,4,rep,name=provenance" json:"provenance,omitempty"`
	Description string                      `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *RepoInfo) Reset()                    { *m = RepoInfo{} }
func (m *RepoInfo) String() string            { return proto.CompactTextString(m) }
func (*RepoInfo) ProtoMessage()               {}
func (*RepoInfo) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{9} }

func (m *RepoInfo) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *RepoInfo) GetCreated() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *RepoInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *RepoInfo) GetProvenance() []*Repo {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *RepoInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type RepoInfos struct {
	RepoInfo []*RepoInfo `protobuf:"bytes,1,rep,name=repo_info,json=repoInfo" json:"repo_info,omitempty"`
}

func (m *RepoInfos) Reset()                    { *m = RepoInfos{} }
func (m *RepoInfos) String() string            { return proto.CompactTextString(m) }
func (*RepoInfos) ProtoMessage()               {}
func (*RepoInfos) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{10} }

func (m *RepoInfos) GetRepoInfo() []*RepoInfo {
	if m != nil {
		return m.RepoInfo
	}
	return nil
}

type CommitInfo struct {
	Commit       *Commit                     `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	ParentCommit *Commit                     `protobuf:"bytes,2,opt,name=parent_commit,json=parentCommit" json:"parent_commit,omitempty"`
	Started      *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=started" json:"started,omitempty"`
	Finished     *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=finished" json:"finished,omitempty"`
	SizeBytes    uint64                      `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Provenance   []*Commit                   `protobuf:"bytes,6,rep,name=provenance" json:"provenance,omitempty"`
	// this is the block that stores the serialized form of a tree that
	// represents the entire file system hierarchy of the repo at this commit
	Tree *Object `protobuf:"bytes,7,opt,name=tree" json:"tree,omitempty"`
}

func (m *CommitInfo) Reset()                    { *m = CommitInfo{} }
func (m *CommitInfo) String() string            { return proto.CompactTextString(m) }
func (*CommitInfo) ProtoMessage()               {}
func (*CommitInfo) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{11} }

func (m *CommitInfo) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *CommitInfo) GetParentCommit() *Commit {
	if m != nil {
		return m.ParentCommit
	}
	return nil
}

func (m *CommitInfo) GetStarted() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *CommitInfo) GetFinished() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *CommitInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *CommitInfo) GetProvenance() []*Commit {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *CommitInfo) GetTree() *Object {
	if m != nil {
		return m.Tree
	}
	return nil
}

type CommitInfos struct {
	CommitInfo []*CommitInfo `protobuf:"bytes,1,rep,name=commit_info,json=commitInfo" json:"commit_info,omitempty"`
}

func (m *CommitInfos) Reset()                    { *m = CommitInfos{} }
func (m *CommitInfos) String() string            { return proto.CompactTextString(m) }
func (*CommitInfos) ProtoMessage()               {}
func (*CommitInfos) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{12} }

func (m *CommitInfos) GetCommitInfo() []*CommitInfo {
	if m != nil {
		return m.CommitInfo
	}
	return nil
}

type FileInfo struct {
	File      *File    `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	FileType  FileType `protobuf:"varint,2,opt,name=file_type,json=fileType,proto3,enum=pfs.FileType" json:"file_type,omitempty"`
	SizeBytes uint64   `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// the base names (i.e. just the filenames, not the full paths) of
	// the children
	Children []string  `protobuf:"bytes,6,rep,name=children" json:"children,omitempty"`
	Objects  []*Object `protobuf:"bytes,8,rep,name=objects" json:"objects,omitempty"`
	Hash     []byte    `protobuf:"bytes,7,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{13} }

func (m *FileInfo) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileInfo) GetFileType() FileType {
	if m != nil {
		return m.FileType
	}
	return FileType_RESERVED
}

func (m *FileInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FileInfo) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *FileInfo) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *FileInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type FileInfos struct {
	FileInfo []*FileInfo `protobuf:"bytes,1,rep,name=file_info,json=fileInfo" json:"file_info,omitempty"`
}

func (m *FileInfos) Reset()                    { *m = FileInfos{} }
func (m *FileInfos) String() string            { return proto.CompactTextString(m) }
func (*FileInfos) ProtoMessage()               {}
func (*FileInfos) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{14} }

func (m *FileInfos) GetFileInfo() []*FileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

type ByteRange struct {
	Lower uint64 `protobuf:"varint,1,opt,name=lower,proto3" json:"lower,omitempty"`
	Upper uint64 `protobuf:"varint,2,opt,name=upper,proto3" json:"upper,omitempty"`
}

func (m *ByteRange) Reset()                    { *m = ByteRange{} }
func (m *ByteRange) String() string            { return proto.CompactTextString(m) }
func (*ByteRange) ProtoMessage()               {}
func (*ByteRange) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{15} }

func (m *ByteRange) GetLower() uint64 {
	if m != nil {
		return m.Lower
	}
	return 0
}

func (m *ByteRange) GetUpper() uint64 {
	if m != nil {
		return m.Upper
	}
	return 0
}

type BlockRef struct {
	Block *Block     `protobuf:"bytes,1,opt,name=block" json:"block,omitempty"`
	Range *ByteRange `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
}

func (m *BlockRef) Reset()                    { *m = BlockRef{} }
func (m *BlockRef) String() string            { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()               {}
func (*BlockRef) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{16} }

func (m *BlockRef) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BlockRef) GetRange() *ByteRange {
	if m != nil {
		return m.Range
	}
	return nil
}

type ObjectInfo struct {
	Object   *Object   `protobuf:"bytes,1,opt,name=object" json:"object,omitempty"`
	BlockRef *BlockRef `protobuf:"bytes,2,opt,name=block_ref,json=blockRef" json:"block_ref,omitempty"`
}

func (m *ObjectInfo) Reset()                    { *m = ObjectInfo{} }
func (m *ObjectInfo) String() string            { return proto.CompactTextString(m) }
func (*ObjectInfo) ProtoMessage()               {}
func (*ObjectInfo) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{17} }

func (m *ObjectInfo) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *ObjectInfo) GetBlockRef() *BlockRef {
	if m != nil {
		return m.BlockRef
	}
	return nil
}

type CreateRepoRequest struct {
	Repo        *Repo   `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Provenance  []*Repo `protobuf:"bytes,2,rep,name=provenance" json:"provenance,omitempty"`
	Description string  `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Update      bool    `protobuf:"varint,4,opt,name=update,proto3" json:"update,omitempty"`
}

func (m *CreateRepoRequest) Reset()                    { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()               {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{18} }

func (m *CreateRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *CreateRepoRequest) GetProvenance() []*Repo {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateRepoRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

type InspectRepoRequest struct {
	Repo *Repo `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
}

func (m *InspectRepoRequest) Reset()                    { *m = InspectRepoRequest{} }
func (m *InspectRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectRepoRequest) ProtoMessage()               {}
func (*InspectRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{19} }

func (m *InspectRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

type ListRepoRequest struct {
	Provenance []*Repo `protobuf:"bytes,1,rep,name=provenance" json:"provenance,omitempty"`
}

func (m *ListRepoRequest) Reset()                    { *m = ListRepoRequest{} }
func (m *ListRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRepoRequest) ProtoMessage()               {}
func (*ListRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{20} }

func (m *ListRepoRequest) GetProvenance() []*Repo {
	if m != nil {
		return m.Provenance
	}
	return nil
}

type DeleteRepoRequest struct {
	Repo  *Repo `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Force bool  `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	All   bool  `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeleteRepoRequest) Reset()                    { *m = DeleteRepoRequest{} }
func (m *DeleteRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRepoRequest) ProtoMessage()               {}
func (*DeleteRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{21} }

func (m *DeleteRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *DeleteRepoRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *DeleteRepoRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type StartCommitRequest struct {
	// Parent.ID may be empty in which case the commit that Branch points to will be used as the parent.
	// If branch is empty, or if branch does not exist, the commit will have no parent.
	Parent     *Commit   `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	Branch     string    `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance []*Commit `protobuf:"bytes,2,rep,name=provenance" json:"provenance,omitempty"`
}

func (m *StartCommitRequest) Reset()                    { *m = StartCommitRequest{} }
func (m *StartCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*StartCommitRequest) ProtoMessage()               {}
func (*StartCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{22} }

func (m *StartCommitRequest) GetParent() *Commit {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *StartCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *StartCommitRequest) GetProvenance() []*Commit {
	if m != nil {
		return m.Provenance
	}
	return nil
}

type BuildCommitRequest struct {
	Parent     *Commit   `protobuf:"bytes,1,opt,name=parent" json:"parent,omitempty"`
	Branch     string    `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance []*Commit `protobuf:"bytes,2,rep,name=provenance" json:"provenance,omitempty"`
	Tree       *Object   `protobuf:"bytes,3,opt,name=tree" json:"tree,omitempty"`
}

func (m *BuildCommitRequest) Reset()                    { *m = BuildCommitRequest{} }
func (m *BuildCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*BuildCommitRequest) ProtoMessage()               {}
func (*BuildCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{23} }

func (m *BuildCommitRequest) GetParent() *Commit {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *BuildCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *BuildCommitRequest) GetProvenance() []*Commit {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BuildCommitRequest) GetTree() *Object {
	if m != nil {
		return m.Tree
	}
	return nil
}

type FinishCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
}

func (m *FinishCommitRequest) Reset()                    { *m = FinishCommitRequest{} }
func (m *FinishCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*FinishCommitRequest) ProtoMessage()               {}
func (*FinishCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{24} }

func (m *FinishCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type InspectCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
}

func (m *InspectCommitRequest) Reset()                    { *m = InspectCommitRequest{} }
func (m *InspectCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectCommitRequest) ProtoMessage()               {}
func (*InspectCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{25} }

func (m *InspectCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type ListCommitRequest struct {
	Repo   *Repo   `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	From   *Commit `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
	To     *Commit `protobuf:"bytes,3,opt,name=to" json:"to,omitempty"`
	Number uint64  `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *ListCommitRequest) Reset()                    { *m = ListCommitRequest{} }
func (m *ListCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*ListCommitRequest) ProtoMessage()               {}
func (*ListCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{26} }

func (m *ListCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListCommitRequest) GetTo() *Commit {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListCommitRequest) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

type ListBranchRequest struct {
	Repo *Repo `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
}

func (m *ListBranchRequest) Reset()                    { *m = ListBranchRequest{} }
func (m *ListBranchRequest) String() string            { return proto.CompactTextString(m) }
func (*ListBranchRequest) ProtoMessage()               {}
func (*ListBranchRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{27} }

func (m *ListBranchRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

type SetBranchRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	Branch string  `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
}

func (m *SetBranchRequest) Reset()                    { *m = SetBranchRequest{} }
func (m *SetBranchRequest) String() string            { return proto.CompactTextString(m) }
func (*SetBranchRequest) ProtoMessage()               {}
func (*SetBranchRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{28} }

func (m *SetBranchRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *SetBranchRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

type DeleteBranchRequest struct {
	Repo   *Repo  `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Branch string `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
}

func (m *DeleteBranchRequest) Reset()                    { *m = DeleteBranchRequest{} }
func (m *DeleteBranchRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteBranchRequest) ProtoMessage()               {}
func (*DeleteBranchRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{29} }

func (m *DeleteBranchRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *DeleteBranchRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

type DeleteCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
}

func (m *DeleteCommitRequest) Reset()                    { *m = DeleteCommitRequest{} }
func (m *DeleteCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteCommitRequest) ProtoMessage()               {}
func (*DeleteCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{30} }

func (m *DeleteCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type FlushCommitRequest struct {
	Commits []*Commit `protobuf:"bytes,1,rep,name=commits" json:"commits,omitempty"`
	ToRepos []*Repo   `protobuf:"bytes,2,rep,name=to_repos,json=toRepos" json:"to_repos,omitempty"`
}

func (m *FlushCommitRequest) Reset()                    { *m = FlushCommitRequest{} }
func (m *FlushCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*FlushCommitRequest) ProtoMessage()               {}
func (*FlushCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{31} }

func (m *FlushCommitRequest) GetCommits() []*Commit {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *FlushCommitRequest) GetToRepos() []*Repo {
	if m != nil {
		return m.ToRepos
	}
	return nil
}

type SubscribeCommitRequest struct {
	Repo   *Repo  `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Branch string `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	// only commits created since this commit are returned
	From *Commit `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
}

func (m *SubscribeCommitRequest) Reset()                    { *m = SubscribeCommitRequest{} }
func (m *SubscribeCommitRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeCommitRequest) ProtoMessage()               {}
func (*SubscribeCommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{32} }

func (m *SubscribeCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *SubscribeCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *SubscribeCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

type GetFileRequest struct {
	File        *File `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	OffsetBytes int64 `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
	SizeBytes   int64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
}

func (m *GetFileRequest) Reset()                    { *m = GetFileRequest{} }
func (m *GetFileRequest) String() string            { return proto.CompactTextString(m) }
func (*GetFileRequest) ProtoMessage()               {}
func (*GetFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{33} }

func (m *GetFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetFileRequest) GetOffsetBytes() int64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

func (m *GetFileRequest) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

type PutFileRequest struct {
	File  *File  `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Url   string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
	// applies only to URLs that can be recursively walked, for example s3:// URLs
	Recursive bool `protobuf:"varint,6,opt,name=recursive,proto3" json:"recursive,omitempty"`
	// Delimiter causes data to be broken up into separate files with File.Path
	// as a prefix.
	Delimiter Delimiter `protobuf:"varint,7,opt,name=delimiter,proto3,enum=pfs.Delimiter" json:"delimiter,omitempty"`
	// TargetFileDatums specifies the target number of datums in each written
	// file it may be lower if data does not split evenly, but will never be
	// higher, unless the value is 0.
	TargetFileDatums int64 `protobuf:"varint,8,opt,name=target_file_datums,json=targetFileDatums,proto3" json:"target_file_datums,omitempty"`
	// TargetFileBytes specifies the target number of bytes in each written
	// file, files may have more or fewer bytes than the target.
	TargetFileBytes int64 `protobuf:"varint,9,opt,name=target_file_bytes,json=targetFileBytes,proto3" json:"target_file_bytes,omitempty"`
}

func (m *PutFileRequest) Reset()                    { *m = PutFileRequest{} }
func (m *PutFileRequest) String() string            { return proto.CompactTextString(m) }
func (*PutFileRequest) ProtoMessage()               {}
func (*PutFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{34} }

func (m *PutFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *PutFileRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PutFileRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PutFileRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *PutFileRequest) GetDelimiter() Delimiter {
	if m != nil {
		return m.Delimiter
	}
	return Delimiter_NONE
}

func (m *PutFileRequest) GetTargetFileDatums() int64 {
	if m != nil {
		return m.TargetFileDatums
	}
	return 0
}

func (m *PutFileRequest) GetTargetFileBytes() int64 {
	if m != nil {
		return m.TargetFileBytes
	}
	return 0
}

type InspectFileRequest struct {
	File *File `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *InspectFileRequest) Reset()                    { *m = InspectFileRequest{} }
func (m *InspectFileRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectFileRequest) ProtoMessage()               {}
func (*InspectFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{35} }

func (m *InspectFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type ListFileRequest struct {
	File *File `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *ListFileRequest) Reset()                    { *m = ListFileRequest{} }
func (m *ListFileRequest) String() string            { return proto.CompactTextString(m) }
func (*ListFileRequest) ProtoMessage()               {}
func (*ListFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{36} }

func (m *ListFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type GlobFileRequest struct {
	Commit  *Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	Pattern string  `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
}

func (m *GlobFileRequest) Reset()                    { *m = GlobFileRequest{} }
func (m *GlobFileRequest) String() string            { return proto.CompactTextString(m) }
func (*GlobFileRequest) ProtoMessage()               {}
func (*GlobFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{37} }

func (m *GlobFileRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *GlobFileRequest) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

type DiffFileRequest struct {
	NewFile *File `protobuf:"bytes,1,opt,name=new_file,json=newFile" json:"new_file,omitempty"`
	// OldFile may be left nil in which case the same path in the parent of
	// NewFile's commit will be used.
	OldFile *File `protobuf:"bytes,2,opt,name=old_file,json=oldFile" json:"old_file,omitempty"`
}

func (m *DiffFileRequest) Reset()                    { *m = DiffFileRequest{} }
func (m *DiffFileRequest) String() string            { return proto.CompactTextString(m) }
func (*DiffFileRequest) ProtoMessage()               {}
func (*DiffFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{38} }

func (m *DiffFileRequest) GetNewFile() *File {
	if m != nil {
		return m.NewFile
	}
	return nil
}

func (m *DiffFileRequest) GetOldFile() *File {
	if m != nil {
		return m.OldFile
	}
	return nil
}

type DiffFileResponse struct {
	NewFiles []*FileInfo `protobuf:"bytes,1,rep,name=new_files,json=newFiles" json:"new_files,omitempty"`
	OldFiles []*FileInfo `protobuf:"bytes,2,rep,name=old_files,json=oldFiles" json:"old_files,omitempty"`
}

func (m *DiffFileResponse) Reset()                    { *m = DiffFileResponse{} }
func (m *DiffFileResponse) String() string            { return proto.CompactTextString(m) }
func (*DiffFileResponse) ProtoMessage()               {}
func (*DiffFileResponse) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{39} }

func (m *DiffFileResponse) GetNewFiles() []*FileInfo {
	if m != nil {
		return m.NewFiles
	}
	return nil
}

func (m *DiffFileResponse) GetOldFiles() []*FileInfo {
	if m != nil {
		return m.OldFiles
	}
	return nil
}

type DeleteFileRequest struct {
	File *File `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
}

func (m *DeleteFileRequest) Reset()                    { *m = DeleteFileRequest{} }
func (m *DeleteFileRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteFileRequest) ProtoMessage()               {}
func (*DeleteFileRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{40} }

func (m *DeleteFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type PutObjectRequest struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Tags  []*Tag `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *PutObjectRequest) Reset()                    { *m = PutObjectRequest{} }
func (m *PutObjectRequest) String() string            { return proto.CompactTextString(m) }
func (*PutObjectRequest) ProtoMessage()               {}
func (*PutObjectRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{41} }

func (m *PutObjectRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PutObjectRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type GetObjectsRequest struct {
	Objects     []*Object `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
	OffsetBytes uint64    `protobuf:"varint,2,opt,name=offset_bytes,json=offsetBytes,proto3" json:"offset_bytes,omitempty"`
	SizeBytes   uint64    `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
}

func (m *GetObjectsRequest) Reset()                    { *m = GetObjectsRequest{} }
func (m *GetObjectsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetObjectsRequest) ProtoMessage()               {}
func (*GetObjectsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{42} }

func (m *GetObjectsRequest) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *GetObjectsRequest) GetOffsetBytes() uint64 {
	if m != nil {
		return m.OffsetBytes
	}
	return 0
}

func (m *GetObjectsRequest) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

type TagObjectRequest struct {
	Object *Object `protobuf:"bytes,1,opt,name=object" json:"object,omitempty"`
	Tags   []*Tag  `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
}

func (m *TagObjectRequest) Reset()                    { *m = TagObjectRequest{} }
func (m *TagObjectRequest) String() string            { return proto.CompactTextString(m) }
func (*TagObjectRequest) ProtoMessage()               {}
func (*TagObjectRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{43} }

func (m *TagObjectRequest) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *TagObjectRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ListObjectsRequest struct {
}

func (m *ListObjectsRequest) Reset()                    { *m = ListObjectsRequest{} }
func (m *ListObjectsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListObjectsRequest) ProtoMessage()               {}
func (*ListObjectsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{44} }

type ListTagsRequest struct {
	Prefix        string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	IncludeObject bool   `protobuf:"varint,2,opt,name=includeObject,proto3" json:"includeObject,omitempty"`
}

func (m *ListTagsRequest) Reset()                    { *m = ListTagsRequest{} }
func (m *ListTagsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTagsRequest) ProtoMessage()               {}
func (*ListTagsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{45} }

func (m *ListTagsRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *ListTagsRequest) GetIncludeObject() bool {
	if m != nil {
		return m.IncludeObject
	}
	return false
}

type ListTagsResponse struct {
	Tag    string  `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	Object *Object `protobuf:"bytes,2,opt,name=object" json:"object,omitempty"`
}

func (m *ListTagsResponse) Reset()                    { *m = ListTagsResponse{} }
func (m *ListTagsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTagsResponse) ProtoMessage()               {}
func (*ListTagsResponse) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{46} }

func (m *ListTagsResponse) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *ListTagsResponse) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type DeleteObjectsRequest struct {
	Objects []*Object `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty"`
}

func (m *DeleteObjectsRequest) Reset()                    { *m = DeleteObjectsRequest{} }
func (m *DeleteObjectsRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteObjectsRequest) ProtoMessage()               {}
func (*DeleteObjectsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{47} }

func (m *DeleteObjectsRequest) GetObjects() []*Object {
	if m != nil {
		return m.Objects
	}
	return nil
}

type DeleteObjectsResponse struct {
}

func (m *DeleteObjectsResponse) Reset()                    { *m = DeleteObjectsResponse{} }
func (m *DeleteObjectsResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteObjectsResponse) ProtoMessage()               {}
func (*DeleteObjectsResponse) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{48} }

type DeleteTagsRequest struct {
	Tags []string `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
}

func (m *DeleteTagsRequest) Reset()                    { *m = DeleteTagsRequest{} }
func (m *DeleteTagsRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteTagsRequest) ProtoMessage()               {}
func (*DeleteTagsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{49} }

func (m *DeleteTagsRequest) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type DeleteTagsResponse struct {
}

func (m *DeleteTagsResponse) Reset()                    { *m = DeleteTagsResponse{} }
func (m *DeleteTagsResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteTagsResponse) ProtoMessage()               {}
func (*DeleteTagsResponse) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{50} }

type CheckObjectRequest struct {
	Object *Object `protobuf:"bytes,1,opt,name=object" json:"object,omitempty"`
}

func (m *CheckObjectRequest) Reset()                    { *m = CheckObjectRequest{} }
func (m *CheckObjectRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckObjectRequest) ProtoMessage()               {}
func (*CheckObjectRequest) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{51} }

func (m *CheckObjectRequest) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

type CheckObjectResponse struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
}

func (m *CheckObjectResponse) Reset()                    { *m = CheckObjectResponse{} }
func (m *CheckObjectResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckObjectResponse) ProtoMessage()               {}
func (*CheckObjectResponse) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{52} }

func (m *CheckObjectResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type ObjectIndex struct {
	Objects map[string]*BlockRef `protobuf:"bytes,1,rep,name=objects" json:"objects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Tags    map[string]*Object   `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ObjectIndex) Reset()                    { *m = ObjectIndex{} }
func (m *ObjectIndex) String() string            { return proto.CompactTextString(m) }
func (*ObjectIndex) ProtoMessage()               {}
func (*ObjectIndex) Descriptor() ([]byte, []int) { return fileDescriptorPfs, []int{53} }

func (m *ObjectIndex) GetObjects() map[string]*BlockRef {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *ObjectIndex) GetTags() map[string]*Object {
	if m != nil {
		return m.Tags
	}
	return nil
}

func init() {
	proto.RegisterType((*Repo)(nil), "pfs.Repo")
	proto.RegisterType((*Commit)(nil), "pfs.Commit")
	proto.RegisterType((*Commits)(nil), "pfs.Commits")
	proto.RegisterType((*BranchInfo)(nil), "pfs.BranchInfo")
	proto.RegisterType((*BranchInfos)(nil), "pfs.BranchInfos")
	proto.RegisterType((*File)(nil), "pfs.File")
	proto.RegisterType((*Block)(nil), "pfs.Block")
	proto.RegisterType((*Object)(nil), "pfs.Object")
	proto.RegisterType((*Tag)(nil), "pfs.Tag")
	proto.RegisterType((*RepoInfo)(nil), "pfs.RepoInfo")
	proto.RegisterType((*RepoInfos)(nil), "pfs.RepoInfos")
	proto.RegisterType((*CommitInfo)(nil), "pfs.CommitInfo")
	proto.RegisterType((*CommitInfos)(nil), "pfs.CommitInfos")
	proto.RegisterType((*FileInfo)(nil), "pfs.FileInfo")
	proto.RegisterType((*FileInfos)(nil), "pfs.FileInfos")
	proto.RegisterType((*ByteRange)(nil), "pfs.ByteRange")
	proto.RegisterType((*BlockRef)(nil), "pfs.BlockRef")
	proto.RegisterType((*ObjectInfo)(nil), "pfs.ObjectInfo")
	proto.RegisterType((*CreateRepoRequest)(nil), "pfs.CreateRepoRequest")
	proto.RegisterType((*InspectRepoRequest)(nil), "pfs.InspectRepoRequest")
	proto.RegisterType((*ListRepoRequest)(nil), "pfs.ListRepoRequest")
	proto.RegisterType((*DeleteRepoRequest)(nil), "pfs.DeleteRepoRequest")
	proto.RegisterType((*StartCommitRequest)(nil), "pfs.StartCommitRequest")
	proto.RegisterType((*BuildCommitRequest)(nil), "pfs.BuildCommitRequest")
	proto.RegisterType((*FinishCommitRequest)(nil), "pfs.FinishCommitRequest")
	proto.RegisterType((*InspectCommitRequest)(nil), "pfs.InspectCommitRequest")
	proto.RegisterType((*ListCommitRequest)(nil), "pfs.ListCommitRequest")
	proto.RegisterType((*ListBranchRequest)(nil), "pfs.ListBranchRequest")
	proto.RegisterType((*SetBranchRequest)(nil), "pfs.SetBranchRequest")
	proto.RegisterType((*DeleteBranchRequest)(nil), "pfs.DeleteBranchRequest")
	proto.RegisterType((*DeleteCommitRequest)(nil), "pfs.DeleteCommitRequest")
	proto.RegisterType((*FlushCommitRequest)(nil), "pfs.FlushCommitRequest")
	proto.RegisterType((*SubscribeCommitRequest)(nil), "pfs.SubscribeCommitRequest")
	proto.RegisterType((*GetFileRequest)(nil), "pfs.GetFileRequest")
	proto.RegisterType((*PutFileRequest)(nil), "pfs.PutFileRequest")
	proto.RegisterType((*InspectFileRequest)(nil), "pfs.InspectFileRequest")
	proto.RegisterType((*ListFileRequest)(nil), "pfs.ListFileRequest")
	proto.RegisterType((*GlobFileRequest)(nil), "pfs.GlobFileRequest")
	proto.RegisterType((*DiffFileRequest)(nil), "pfs.DiffFileRequest")
	proto.RegisterType((*DiffFileResponse)(nil), "pfs.DiffFileResponse")
	proto.RegisterType((*DeleteFileRequest)(nil), "pfs.DeleteFileRequest")
	proto.RegisterType((*PutObjectRequest)(nil), "pfs.PutObjectRequest")
	proto.RegisterType((*GetObjectsRequest)(nil), "pfs.GetObjectsRequest")
	proto.RegisterType((*TagObjectRequest)(nil), "pfs.TagObjectRequest")
	proto.RegisterType((*ListObjectsRequest)(nil), "pfs.ListObjectsRequest")
	proto.RegisterType((*ListTagsRequest)(nil), "pfs.ListTagsRequest")
	proto.RegisterType((*ListTagsResponse)(nil), "pfs.ListTagsResponse")
	proto.RegisterType((*DeleteObjectsRequest)(nil), "pfs.DeleteObjectsRequest")
	proto.RegisterType((*DeleteObjectsResponse)(nil), "pfs.DeleteObjectsResponse")
	proto.RegisterType((*DeleteTagsRequest)(nil), "pfs.DeleteTagsRequest")
	proto.RegisterType((*DeleteTagsResponse)(nil), "pfs.DeleteTagsResponse")
	proto.RegisterType((*CheckObjectRequest)(nil), "pfs.CheckObjectRequest")
	proto.RegisterType((*CheckObjectResponse)(nil), "pfs.CheckObjectResponse")
	proto.RegisterType((*ObjectIndex)(nil), "pfs.ObjectIndex")
	proto.RegisterEnum("pfs.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("pfs.Delimiter", Delimiter_name, Delimiter_value)
	proto.RegisterEnum("pfs.ListFileMode", ListFileMode_name, ListFileMode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	// Repo rpcs
	// CreateRepo creates a new repo.
	// An error is returned if the repo already exists.
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (*RepoInfos, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// Commit rpcs
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error)
	// ListCommit returns info about all commits.
	ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (*CommitInfos, error)
	// DeleteCommit deletes a commit.
	DeleteCommit(ctx context.Context, in *DeleteCommitRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// FlushCommit waits for downstream commits to finish
	FlushCommit(ctx context.Context, in *FlushCommitRequest, opts ...grpc.CallOption) (API_FlushCommitClient, error)
	// SubscribeCommit subscribes for new commits on a given branch
	SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error)
	// BuildCommit builds a commit that's backed by the given tree
	BuildCommit(ctx context.Context, in *BuildCommitRequest, opts ...grpc.CallOption) (*Commit, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (*BranchInfos, error)
	// SetBranch assigns a commit and its ancestors to a branch.
	SetBranch(ctx context.Context, in *SetBranchRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// File rpcs
	// PutFile writes the specified file to pfs.
	PutFile(ctx context.Context, opts ...grpc.CallOption) (API_PutFileClient, error)
	// GetFile returns a byte stream of the contents of the file.
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error)
	// InspectFile returns info about a file.
	InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error)
	// ListFile returns info about all files.
	ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (*FileInfos, error)
	// GlobFile returns info about all files.
	GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (*FileInfos, error)
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (*DiffFileResponse, error)
	// DeleteFile deletes a file.
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/CreateRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error) {
	out := new(RepoInfo)
	err := grpc.Invoke(ctx, "/pfs.API/InspectRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (*RepoInfos, error) {
	out := new(RepoInfos)
	err := grpc.Invoke(ctx, "/pfs.API/ListRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/DeleteRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error) {
	out := new(Commit)
	err := grpc.Invoke(ctx, "/pfs.API/StartCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/FinishCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error) {
	out := new(CommitInfo)
	err := grpc.Invoke(ctx, "/pfs.API/InspectCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (*CommitInfos, error) {
	out := new(CommitInfos)
	err := grpc.Invoke(ctx, "/pfs.API/ListCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteCommit(ctx context.Context, in *DeleteCommitRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/DeleteCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FlushCommit(ctx context.Context, in *FlushCommitRequest, opts ...grpc.CallOption) (API_FlushCommitClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[0], c.cc, "/pfs.API/FlushCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFlushCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FlushCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIFlushCommitClient struct {
	grpc.ClientStream
}

func (x *aPIFlushCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[1], c.cc, "/pfs.API/SubscribeCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPISubscribeCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_SubscribeCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPISubscribeCommitClient struct {
	grpc.ClientStream
}

func (x *aPISubscribeCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) BuildCommit(ctx context.Context, in *BuildCommitRequest, opts ...grpc.CallOption) (*Commit, error) {
	out := new(Commit)
	err := grpc.Invoke(ctx, "/pfs.API/BuildCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (*BranchInfos, error) {
	out := new(BranchInfos)
	err := grpc.Invoke(ctx, "/pfs.API/ListBranch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) SetBranch(ctx context.Context, in *SetBranchRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/SetBranch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/DeleteBranch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PutFile(ctx context.Context, opts ...grpc.CallOption) (API_PutFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[2], c.cc, "/pfs.API/PutFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIPutFileClient{stream}
	return x, nil
}

type API_PutFileClient interface {
	Send(*PutFileRequest) error
	CloseAndRecv() (*google_protobuf.Empty, error)
	grpc.ClientStream
}

type aPIPutFileClient struct {
	grpc.ClientStream
}

func (x *aPIPutFileClient) Send(m *PutFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIPutFileClient) CloseAndRecv() (*google_protobuf.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(google_protobuf.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[3], c.cc, "/pfs.API/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetFileClient interface {
	Recv() (*google_protobuf2.BytesValue, error)
	grpc.ClientStream
}

type aPIGetFileClient struct {
	grpc.ClientStream
}

func (x *aPIGetFileClient) Recv() (*google_protobuf2.BytesValue, error) {
	m := new(google_protobuf2.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := grpc.Invoke(ctx, "/pfs.API/InspectFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (*FileInfos, error) {
	out := new(FileInfos)
	err := grpc.Invoke(ctx, "/pfs.API/ListFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (*FileInfos, error) {
	out := new(FileInfos)
	err := grpc.Invoke(ctx, "/pfs.API/GlobFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (*DiffFileResponse, error) {
	out := new(DiffFileResponse)
	err := grpc.Invoke(ctx, "/pfs.API/DiffFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/DeleteFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.API/DeleteAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	// Repo rpcs
	// CreateRepo creates a new repo.
	// An error is returned if the repo already exists.
	CreateRepo(context.Context, *CreateRepoRequest) (*google_protobuf.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(context.Context, *InspectRepoRequest) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(context.Context, *ListRepoRequest) (*RepoInfos, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(context.Context, *DeleteRepoRequest) (*google_protobuf.Empty, error)
	// Commit rpcs
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(context.Context, *StartCommitRequest) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(context.Context, *FinishCommitRequest) (*google_protobuf.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(context.Context, *InspectCommitRequest) (*CommitInfo, error)
	// ListCommit returns info about all commits.
	ListCommit(context.Context, *ListCommitRequest) (*CommitInfos, error)
	// DeleteCommit deletes a commit.
	DeleteCommit(context.Context, *DeleteCommitRequest) (*google_protobuf.Empty, error)
	// FlushCommit waits for downstream commits to finish
	FlushCommit(*FlushCommitRequest, API_FlushCommitServer) error
	// SubscribeCommit subscribes for new commits on a given branch
	SubscribeCommit(*SubscribeCommitRequest, API_SubscribeCommitServer) error
	// BuildCommit builds a commit that's backed by the given tree
	BuildCommit(context.Context, *BuildCommitRequest) (*Commit, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(context.Context, *ListBranchRequest) (*BranchInfos, error)
	// SetBranch assigns a commit and its ancestors to a branch.
	SetBranch(context.Context, *SetBranchRequest) (*google_protobuf.Empty, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(context.Context, *DeleteBranchRequest) (*google_protobuf.Empty, error)
	// File rpcs
	// PutFile writes the specified file to pfs.
	PutFile(API_PutFileServer) error
	// GetFile returns a byte stream of the contents of the file.
	GetFile(*GetFileRequest, API_GetFileServer) error
	// InspectFile returns info about a file.
	InspectFile(context.Context, *InspectFileRequest) (*FileInfo, error)
	// ListFile returns info about all files.
	ListFile(context.Context, *ListFileRequest) (*FileInfos, error)
	// GlobFile returns info about all files.
	GlobFile(context.Context, *GlobFileRequest) (*FileInfos, error)
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(context.Context, *DiffFileRequest) (*DiffFileResponse, error)
	// DeleteFile deletes a file.
	DeleteFile(context.Context, *DeleteFileRequest) (*google_protobuf.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectRepo(ctx, req.(*InspectRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListRepo(ctx, req.(*ListRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteRepo(ctx, req.(*DeleteRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/StartCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartCommit(ctx, req.(*StartCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FinishCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).FinishCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/FinishCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).FinishCommit(ctx, req.(*FinishCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectCommit(ctx, req.(*InspectCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListCommit(ctx, req.(*ListCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteCommit(ctx, req.(*DeleteCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FlushCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlushCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).FlushCommit(m, &aPIFlushCommitServer{stream})
}

type API_FlushCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIFlushCommitServer struct {
	grpc.ServerStream
}

func (x *aPIFlushCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SubscribeCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).SubscribeCommit(m, &aPISubscribeCommitServer{stream})
}

type API_SubscribeCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPISubscribeCommitServer struct {
	grpc.ServerStream
}

func (x *aPISubscribeCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_BuildCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).BuildCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/BuildCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).BuildCommit(ctx, req.(*BuildCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListBranch(ctx, req.(*ListBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_SetBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).SetBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/SetBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).SetBranch(ctx, req.(*SetBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteBranch(ctx, req.(*DeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PutFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).PutFile(&aPIPutFileServer{stream})
}

type API_PutFileServer interface {
	SendAndClose(*google_protobuf.Empty) error
	Recv() (*PutFileRequest, error)
	grpc.ServerStream
}

type aPIPutFileServer struct {
	grpc.ServerStream
}

func (x *aPIPutFileServer) SendAndClose(m *google_protobuf.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIPutFileServer) Recv() (*PutFileRequest, error) {
	m := new(PutFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetFile(m, &aPIGetFileServer{stream})
}

type API_GetFileServer interface {
	Send(*google_protobuf2.BytesValue) error
	grpc.ServerStream
}

type aPIGetFileServer struct {
	grpc.ServerStream
}

func (x *aPIGetFileServer) Send(m *google_protobuf2.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectFile(ctx, req.(*InspectFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListFile(ctx, req.(*ListFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GlobFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GlobFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GlobFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/GlobFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GlobFile(ctx, req.(*GlobFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DiffFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiffFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DiffFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DiffFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DiffFile(ctx, req.(*DiffFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pfs.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRepo",
			Handler:    _API_CreateRepo_Handler,
		},
		{
			MethodName: "InspectRepo",
			Handler:    _API_InspectRepo_Handler,
		},
		{
			MethodName: "ListRepo",
			Handler:    _API_ListRepo_Handler,
		},
		{
			MethodName: "DeleteRepo",
			Handler:    _API_DeleteRepo_Handler,
		},
		{
			MethodName: "StartCommit",
			Handler:    _API_StartCommit_Handler,
		},
		{
			MethodName: "FinishCommit",
			Handler:    _API_FinishCommit_Handler,
		},
		{
			MethodName: "InspectCommit",
			Handler:    _API_InspectCommit_Handler,
		},
		{
			MethodName: "ListCommit",
			Handler:    _API_ListCommit_Handler,
		},
		{
			MethodName: "DeleteCommit",
			Handler:    _API_DeleteCommit_Handler,
		},
		{
			MethodName: "BuildCommit",
			Handler:    _API_BuildCommit_Handler,
		},
		{
			MethodName: "ListBranch",
			Handler:    _API_ListBranch_Handler,
		},
		{
			MethodName: "SetBranch",
			Handler:    _API_SetBranch_Handler,
		},
		{
			MethodName: "DeleteBranch",
			Handler:    _API_DeleteBranch_Handler,
		},
		{
			MethodName: "InspectFile",
			Handler:    _API_InspectFile_Handler,
		},
		{
			MethodName: "ListFile",
			Handler:    _API_ListFile_Handler,
		},
		{
			MethodName: "GlobFile",
			Handler:    _API_GlobFile_Handler,
		},
		{
			MethodName: "DiffFile",
			Handler:    _API_DiffFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _API_DeleteFile_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FlushCommit",
			Handler:       _API_FlushCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeCommit",
			Handler:       _API_SubscribeCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutFile",
			Handler:       _API_PutFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _API_GetFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pfs/pfs.proto",
}

// Client API for ObjectAPI service

type ObjectAPIClient interface {
	PutObject(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectClient, error)
	GetObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (ObjectAPI_GetObjectClient, error)
	GetObjects(ctx context.Context, in *GetObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_GetObjectsClient, error)
	TagObject(ctx context.Context, in *TagObjectRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	InspectObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (*ObjectInfo, error)
	// CheckObject checks if an object exists in the blob store without
	// actually reading the object.
	CheckObject(ctx context.Context, in *CheckObjectRequest, opts ...grpc.CallOption) (*CheckObjectResponse, error)
	ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_ListObjectsClient, error)
	DeleteObjects(ctx context.Context, in *DeleteObjectsRequest, opts ...grpc.CallOption) (*DeleteObjectsResponse, error)
	GetTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (ObjectAPI_GetTagClient, error)
	InspectTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*ObjectInfo, error)
	ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (ObjectAPI_ListTagsClient, error)
	DeleteTags(ctx context.Context, in *DeleteTagsRequest, opts ...grpc.CallOption) (*DeleteTagsResponse, error)
	Compact(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type objectAPIClient struct {
	cc *grpc.ClientConn
}

func NewObjectAPIClient(cc *grpc.ClientConn) ObjectAPIClient {
	return &objectAPIClient{cc}
}

func (c *objectAPIClient) PutObject(ctx context.Context, opts ...grpc.CallOption) (ObjectAPI_PutObjectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectAPI_serviceDesc.Streams[0], c.cc, "/pfs.ObjectAPI/PutObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIPutObjectClient{stream}
	return x, nil
}

type ObjectAPI_PutObjectClient interface {
	Send(*PutObjectRequest) error
	CloseAndRecv() (*Object, error)
	grpc.ClientStream
}

type objectAPIPutObjectClient struct {
	grpc.ClientStream
}

func (x *objectAPIPutObjectClient) Send(m *PutObjectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *objectAPIPutObjectClient) CloseAndRecv() (*Object, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) GetObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (ObjectAPI_GetObjectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectAPI_serviceDesc.Streams[1], c.cc, "/pfs.ObjectAPI/GetObject", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetObjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetObjectClient interface {
	Recv() (*google_protobuf2.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetObjectClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetObjectClient) Recv() (*google_protobuf2.BytesValue, error) {
	m := new(google_protobuf2.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) GetObjects(ctx context.Context, in *GetObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_GetObjectsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectAPI_serviceDesc.Streams[2], c.cc, "/pfs.ObjectAPI/GetObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetObjectsClient interface {
	Recv() (*google_protobuf2.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetObjectsClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetObjectsClient) Recv() (*google_protobuf2.BytesValue, error) {
	m := new(google_protobuf2.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) TagObject(ctx context.Context, in *TagObjectRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/TagObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) InspectObject(ctx context.Context, in *Object, opts ...grpc.CallOption) (*ObjectInfo, error) {
	out := new(ObjectInfo)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/InspectObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) CheckObject(ctx context.Context, in *CheckObjectRequest, opts ...grpc.CallOption) (*CheckObjectResponse, error) {
	out := new(CheckObjectResponse)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/CheckObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...grpc.CallOption) (ObjectAPI_ListObjectsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectAPI_serviceDesc.Streams[3], c.cc, "/pfs.ObjectAPI/ListObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIListObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_ListObjectsClient interface {
	Recv() (*Object, error)
	grpc.ClientStream
}

type objectAPIListObjectsClient struct {
	grpc.ClientStream
}

func (x *objectAPIListObjectsClient) Recv() (*Object, error) {
	m := new(Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) DeleteObjects(ctx context.Context, in *DeleteObjectsRequest, opts ...grpc.CallOption) (*DeleteObjectsResponse, error) {
	out := new(DeleteObjectsResponse)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/DeleteObjects", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) GetTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (ObjectAPI_GetTagClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectAPI_serviceDesc.Streams[4], c.cc, "/pfs.ObjectAPI/GetTag", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIGetTagClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_GetTagClient interface {
	Recv() (*google_protobuf2.BytesValue, error)
	grpc.ClientStream
}

type objectAPIGetTagClient struct {
	grpc.ClientStream
}

func (x *objectAPIGetTagClient) Recv() (*google_protobuf2.BytesValue, error) {
	m := new(google_protobuf2.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) InspectTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*ObjectInfo, error) {
	out := new(ObjectInfo)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/InspectTag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) ListTags(ctx context.Context, in *ListTagsRequest, opts ...grpc.CallOption) (ObjectAPI_ListTagsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ObjectAPI_serviceDesc.Streams[5], c.cc, "/pfs.ObjectAPI/ListTags", opts...)
	if err != nil {
		return nil, err
	}
	x := &objectAPIListTagsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ObjectAPI_ListTagsClient interface {
	Recv() (*ListTagsResponse, error)
	grpc.ClientStream
}

type objectAPIListTagsClient struct {
	grpc.ClientStream
}

func (x *objectAPIListTagsClient) Recv() (*ListTagsResponse, error) {
	m := new(ListTagsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *objectAPIClient) DeleteTags(ctx context.Context, in *DeleteTagsRequest, opts ...grpc.CallOption) (*DeleteTagsResponse, error) {
	out := new(DeleteTagsResponse)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/DeleteTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAPIClient) Compact(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pfs.ObjectAPI/Compact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ObjectAPI service

type ObjectAPIServer interface {
	PutObject(ObjectAPI_PutObjectServer) error
	GetObject(*Object, ObjectAPI_GetObjectServer) error
	GetObjects(*GetObjectsRequest, ObjectAPI_GetObjectsServer) error
	TagObject(context.Context, *TagObjectRequest) (*google_protobuf.Empty, error)
	InspectObject(context.Context, *Object) (*ObjectInfo, error)
	// CheckObject checks if an object exists in the blob store without
	// actually reading the object.
	CheckObject(context.Context, *CheckObjectRequest) (*CheckObjectResponse, error)
	ListObjects(*ListObjectsRequest, ObjectAPI_ListObjectsServer) error
	DeleteObjects(context.Context, *DeleteObjectsRequest) (*DeleteObjectsResponse, error)
	GetTag(*Tag, ObjectAPI_GetTagServer) error
	InspectTag(context.Context, *Tag) (*ObjectInfo, error)
	ListTags(*ListTagsRequest, ObjectAPI_ListTagsServer) error
	DeleteTags(context.Context, *DeleteTagsRequest) (*DeleteTagsResponse, error)
	Compact(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
}

func RegisterObjectAPIServer(s *grpc.Server, srv ObjectAPIServer) {
	s.RegisterService(&_ObjectAPI_serviceDesc, srv)
}

func _ObjectAPI_PutObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ObjectAPIServer).PutObject(&objectAPIPutObjectServer{stream})
}

type ObjectAPI_PutObjectServer interface {
	SendAndClose(*Object) error
	Recv() (*PutObjectRequest, error)
	grpc.ServerStream
}

type objectAPIPutObjectServer struct {
	grpc.ServerStream
}

func (x *objectAPIPutObjectServer) SendAndClose(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func (x *objectAPIPutObjectServer) Recv() (*PutObjectRequest, error) {
	m := new(PutObjectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ObjectAPI_GetObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Object)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetObject(m, &objectAPIGetObjectServer{stream})
}

type ObjectAPI_GetObjectServer interface {
	Send(*google_protobuf2.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetObjectServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetObjectServer) Send(m *google_protobuf2.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_GetObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetObjects(m, &objectAPIGetObjectsServer{stream})
}

type ObjectAPI_GetObjectsServer interface {
	Send(*google_protobuf2.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetObjectsServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetObjectsServer) Send(m *google_protobuf2.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_TagObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).TagObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/TagObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).TagObject(ctx, req.(*TagObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_InspectObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Object)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).InspectObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/InspectObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).InspectObject(ctx, req.(*Object))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_CheckObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).CheckObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/CheckObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).CheckObject(ctx, req.(*CheckObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_ListObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).ListObjects(m, &objectAPIListObjectsServer{stream})
}

type ObjectAPI_ListObjectsServer interface {
	Send(*Object) error
	grpc.ServerStream
}

type objectAPIListObjectsServer struct {
	grpc.ServerStream
}

func (x *objectAPIListObjectsServer) Send(m *Object) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_DeleteObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).DeleteObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/DeleteObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).DeleteObjects(ctx, req.(*DeleteObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_GetTag_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Tag)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).GetTag(m, &objectAPIGetTagServer{stream})
}

type ObjectAPI_GetTagServer interface {
	Send(*google_protobuf2.BytesValue) error
	grpc.ServerStream
}

type objectAPIGetTagServer struct {
	grpc.ServerStream
}

func (x *objectAPIGetTagServer) Send(m *google_protobuf2.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_InspectTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).InspectTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/InspectTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).InspectTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_ListTags_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListTagsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ObjectAPIServer).ListTags(m, &objectAPIListTagsServer{stream})
}

type ObjectAPI_ListTagsServer interface {
	Send(*ListTagsResponse) error
	grpc.ServerStream
}

type objectAPIListTagsServer struct {
	grpc.ServerStream
}

func (x *objectAPIListTagsServer) Send(m *ListTagsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ObjectAPI_DeleteTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).DeleteTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/DeleteTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).DeleteTags(ctx, req.(*DeleteTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAPI_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAPIServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.ObjectAPI/Compact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAPIServer).Compact(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ObjectAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pfs.ObjectAPI",
	HandlerType: (*ObjectAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TagObject",
			Handler:    _ObjectAPI_TagObject_Handler,
		},
		{
			MethodName: "InspectObject",
			Handler:    _ObjectAPI_InspectObject_Handler,
		},
		{
			MethodName: "CheckObject",
			Handler:    _ObjectAPI_CheckObject_Handler,
		},
		{
			MethodName: "DeleteObjects",
			Handler:    _ObjectAPI_DeleteObjects_Handler,
		},
		{
			MethodName: "InspectTag",
			Handler:    _ObjectAPI_InspectTag_Handler,
		},
		{
			MethodName: "DeleteTags",
			Handler:    _ObjectAPI_DeleteTags_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _ObjectAPI_Compact_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PutObject",
			Handler:       _ObjectAPI_PutObject_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetObject",
			Handler:       _ObjectAPI_GetObject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetObjects",
			Handler:       _ObjectAPI_GetObjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListObjects",
			Handler:       _ObjectAPI_ListObjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTag",
			Handler:       _ObjectAPI_GetTag_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTags",
			Handler:       _ObjectAPI_ListTags_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pfs/pfs.proto",
}

func (m *Repo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n1, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *Commits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commit) > 0 {
		for _, msg := range m.Commit {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BranchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Head != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Head.Size()))
		n2, err := m.Head.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *BranchInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BranchInfo) > 0 {
		for _, msg := range m.BranchInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n3, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *RepoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n4, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Created != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Created.Size()))
		n5, err := m.Created.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
	}
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *RepoInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoInfo) > 0 {
		for _, msg := range m.RepoInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CommitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n6, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ParentCommit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.ParentCommit.Size()))
		n7, err := m.ParentCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Started != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Started.Size()))
		n8, err := m.Started.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Finished != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Finished.Size()))
		n9, err := m.Finished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
	}
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Tree != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Tree.Size()))
		n10, err := m.Tree.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CommitInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitInfo) > 0 {
		for _, msg := range m.CommitInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.File.Size()))
		n11, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.FileType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.FileType))
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0x42
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileInfo) > 0 {
		for _, msg := range m.FileInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ByteRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByteRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lower != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Lower))
	}
	if m.Upper != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Upper))
	}
	return i, nil
}

func (m *BlockRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Block.Size()))
		n12, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Range.Size()))
		n13, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ObjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Object.Size()))
		n14, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.BlockRef != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.BlockRef.Size()))
		n15, err := m.BlockRef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *CreateRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n16, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Update {
		dAtA[i] = 0x20
		i++
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InspectRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n17, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *ListRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n18, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Force {
		dAtA[i] = 0x10
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.All {
		dAtA[i] = 0x18
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StartCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Parent != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Parent.Size()))
		n19, err := m.Parent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	return i, nil
}

func (m *BuildCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Parent != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Parent.Size()))
		n20, err := m.Parent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Provenance) > 0 {
		for _, msg := range m.Provenance {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Tree != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Tree.Size()))
		n21, err := m.Tree.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	return i, nil
}

func (m *FinishCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n22, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *InspectCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n23, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *ListCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n24, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.From != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.From.Size()))
		n25, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.To != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.To.Size()))
		n26, err := m.To.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Number != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *ListBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n27, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *SetBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n28, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	return i, nil
}

func (m *DeleteBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n29, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	return i, nil
}

func (m *DeleteCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n30, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *FlushCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, msg := range m.Commits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ToRepos) > 0 {
		for _, msg := range m.ToRepos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SubscribeCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Repo.Size()))
		n31, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if m.From != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.From.Size()))
		n32, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *GetFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.File.Size()))
		n33, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.OffsetBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
	}
	return i, nil
}

func (m *PutFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.File.Size()))
		n34, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.Recursive {
		dAtA[i] = 0x30
		i++
		if m.Recursive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Delimiter != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Delimiter))
	}
	if m.TargetFileDatums != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.TargetFileDatums))
	}
	if m.TargetFileBytes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.TargetFileBytes))
	}
	return i, nil
}

func (m *InspectFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.File.Size()))
		n35, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *ListFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.File.Size()))
		n36, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *GlobFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Commit.Size()))
		n37, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	return i, nil
}

func (m *DiffFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewFile != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.NewFile.Size()))
		n38, err := m.NewFile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.OldFile != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.OldFile.Size()))
		n39, err := m.OldFile.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *DiffFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NewFiles) > 0 {
		for _, msg := range m.NewFiles {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OldFiles) > 0 {
		for _, msg := range m.OldFiles {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.File.Size()))
		n40, err := m.File.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *PutObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetObjectsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetObjectsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OffsetBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
	}
	return i, nil
}

func (m *TagObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Object.Size()))
		n41, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListObjectsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListObjectsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.IncludeObject {
		dAtA[i] = 0x10
		i++
		if m.IncludeObject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Object.Size()))
		n42, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *DeleteObjectsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteObjectsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, msg := range m.Objects {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteObjectsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteObjectsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteTagsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTagsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DeleteTagsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTagsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CheckObjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckObjectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPfs(dAtA, i, uint64(m.Object.Size()))
		n43, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *CheckObjectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckObjectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exists {
		dAtA[i] = 0x8
		i++
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ObjectIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for k, _ := range m.Objects {
			dAtA[i] = 0xa
			i++
			v := m.Objects[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPfs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPfs(uint64(len(k))) + msgSize
			i = encodeVarintPfs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPfs(dAtA, i, uint64(v.Size()))
				n44, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n44
			}
		}
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x12
			i++
			v := m.Tags[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPfs(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPfs(uint64(len(k))) + msgSize
			i = encodeVarintPfs(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPfs(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPfs(dAtA, i, uint64(v.Size()))
				n45, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n45
			}
		}
	}
	return i, nil
}

func encodeFixed64Pfs(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Pfs(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPfs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Repo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *Commits) Size() (n int) {
	var l int
	_ = l
	if len(m.Commit) > 0 {
		for _, e := range m.Commit {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *BranchInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *BranchInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.BranchInfo) > 0 {
		for _, e := range m.BranchInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *Block) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *Object) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *RepoInfo) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *RepoInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoInfo) > 0 {
		for _, e := range m.RepoInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *CommitInfo) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.ParentCommit != nil {
		l = m.ParentCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Tree != nil {
		l = m.Tree.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *CommitInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.CommitInfo) > 0 {
		for _, e := range m.CommitInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovPfs(uint64(m.FileType))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *FileInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.FileInfo) > 0 {
		for _, e := range m.FileInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *ByteRange) Size() (n int) {
	var l int
	_ = l
	if m.Lower != 0 {
		n += 1 + sovPfs(uint64(m.Lower))
	}
	if m.Upper != 0 {
		n += 1 + sovPfs(uint64(m.Upper))
	}
	return n
}

func (m *BlockRef) Size() (n int) {
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *ObjectInfo) Size() (n int) {
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.BlockRef != nil {
		l = m.BlockRef.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *CreateRepoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Update {
		n += 2
	}
	return n
}

func (m *InspectRepoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *ListRepoRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *DeleteRepoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *StartCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *BuildCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Tree != nil {
		l = m.Tree.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *FinishCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *InspectCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *ListCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPfs(uint64(m.Number))
	}
	return n
}

func (m *ListBranchRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *SetBranchRequest) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *DeleteBranchRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *DeleteCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *FlushCommitRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.ToRepos) > 0 {
		for _, e := range m.ToRepos {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *SubscribeCommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *GetFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OffsetBytes != 0 {
		n += 1 + sovPfs(uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	return n
}

func (m *PutFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Recursive {
		n += 2
	}
	if m.Delimiter != 0 {
		n += 1 + sovPfs(uint64(m.Delimiter))
	}
	if m.TargetFileDatums != 0 {
		n += 1 + sovPfs(uint64(m.TargetFileDatums))
	}
	if m.TargetFileBytes != 0 {
		n += 1 + sovPfs(uint64(m.TargetFileBytes))
	}
	return n
}

func (m *InspectFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *ListFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *GlobFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *DiffFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.NewFile != nil {
		l = m.NewFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OldFile != nil {
		l = m.OldFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *DiffFileResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.NewFiles) > 0 {
		for _, e := range m.NewFiles {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.OldFiles) > 0 {
		for _, e := range m.OldFiles {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *DeleteFileRequest) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *PutObjectRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *GetObjectsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.OffsetBytes != 0 {
		n += 1 + sovPfs(uint64(m.OffsetBytes))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	return n
}

func (m *TagObjectRequest) Size() (n int) {
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *ListObjectsRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListTagsRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.IncludeObject {
		n += 2
	}
	return n
}

func (m *ListTagsResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *DeleteObjectsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *DeleteObjectsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteTagsRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	return n
}

func (m *DeleteTagsResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CheckObjectRequest) Size() (n int) {
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}

func (m *CheckObjectResponse) Size() (n int) {
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	return n
}

func (m *ObjectIndex) Size() (n int) {
	var l int
	_ = l
	if len(m.Objects) > 0 {
		for k, v := range m.Objects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPfs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPfs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPfs(uint64(mapEntrySize))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPfs(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPfs(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPfs(uint64(mapEntrySize))
		}
	}
	return n
}

func sovPfs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPfs(x uint64) (n int) {
	return sovPfs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Repo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = append(m.Commit, &Commit{})
			if err := m.Commit[len(m.Commit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchInfo = append(m.BranchInfo, &BranchInfo{})
			if err := m.BranchInfo[len(m.BranchInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &google_protobuf1.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Repo{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoInfo = append(m.RepoInfo, &RepoInfo{})
			if err := m.RepoInfo[len(m.RepoInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentCommit == nil {
				m.ParentCommit = &Commit{}
			}
			if err := m.ParentCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &google_protobuf1.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &google_protobuf1.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Commit{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tree == nil {
				m.Tree = &Object{}
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitInfo = append(m.CommitInfo, &CommitInfo{})
			if err := m.CommitInfo[len(m.CommitInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (FileType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileInfo = append(m.FileInfo, &FileInfo{})
			if err := m.FileInfo[len(m.FileInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ByteRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByteRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByteRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			m.Lower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lower |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			m.Upper = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Upper |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &ByteRange{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockRef == nil {
				m.BlockRef = &BlockRef{}
			}
			if err := m.BlockRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Repo{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Repo{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Commit{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Commit{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Commit{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Commit{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tree == nil {
				m.Tree = &Object{}
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Commit{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRepos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToRepos = append(m.ToRepos, &Repo{})
			if err := m.ToRepos[len(m.ToRepos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBytes", wireType)
			}
			m.OffsetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recursive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recursive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			m.Delimiter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delimiter |= (Delimiter(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetFileDatums", wireType)
			}
			m.TargetFileDatums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetFileDatums |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetFileBytes", wireType)
			}
			m.TargetFileBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetFileBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewFile == nil {
				m.NewFile = &File{}
			}
			if err := m.NewFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldFile == nil {
				m.OldFile = &File{}
			}
			if err := m.OldFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewFiles = append(m.NewFiles, &FileInfo{})
			if err := m.NewFiles[len(m.NewFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldFiles = append(m.OldFiles, &FileInfo{})
			if err := m.OldFiles[len(m.OldFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetObjectsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetObjectsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetObjectsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetBytes", wireType)
			}
			m.OffsetBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListObjectsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListObjectsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListObjectsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeObject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeObject = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteObjectsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteObjectsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteObjectsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &Object{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteObjectsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteObjectsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteObjectsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTagsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTagsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTagsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTagsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTagsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTagsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckObjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckObjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckObjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckObjectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckObjectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckObjectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthPfs
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Objects == nil {
				m.Objects = make(map[string]*BlockRef)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthPfs
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthPfs
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &BlockRef{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Objects[mapkey] = mapvalue
			} else {
				var mapvalue *BlockRef
				m.Objects[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthPfs
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Tags == nil {
				m.Tags = make(map[string]*Object)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthPfs
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthPfs
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Object{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Tags[mapkey] = mapvalue
			} else {
				var mapvalue *Object
				m.Tags[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPfs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPfs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPfs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPfs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPfs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("client/pfs/pfs.proto", fileDescriptorPfs) }

var fileDescriptorPfs = []byte{
	// 2232 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcb, 0x6f, 0xdb, 0xc8,
	0x19, 0x37, 0x25, 0x59, 0xa2, 0x3e, 0xf9, 0x41, 0x4f, 0x14, 0x47, 0xcb, 0x3c, 0xec, 0x9d, 0x78,
	0xd1, 0xc4, 0xbb, 0xb5, 0x0d, 0x67, 0xb7, 0xde, 0xbc, 0x6a, 0xf8, 0x21, 0xa7, 0x5e, 0x78, 0xed,
	0x80, 0xf6, 0xee, 0xa1, 0xc0, 0xc2, 0xa0, 0xa4, 0x91, 0xcc, 0x0d, 0x45, 0x72, 0x49, 0x2a, 0x89,
	0x8b, 0xa2, 0x97, 0x1e, 0xda, 0x7b, 0x0f, 0xed, 0xad, 0xff, 0x49, 0xcf, 0x05, 0x7a, 0xe9, 0x5f,
	0x50, 0x14, 0xe9, 0x1f, 0xd1, 0x6b, 0x31, 0x0f, 0x92, 0xc3, 0x87, 0x2c, 0x3b, 0x40, 0x0f, 0x81,
	0x87, 0xf3, 0x3d, 0xe6, 0xfb, 0xbe, 0xf9, 0x1e, 0xbf, 0x51, 0xa0, 0xd9, 0xb5, 0x2d, 0xe2, 0x84,
	0xeb, 0x5e, 0x3f, 0xa0, 0xff, 0xd6, 0x3c, 0xdf, 0x0d, 0x5d, 0x54, 0xf6, 0xfa, 0x81, 0x7e, 0x77,
	0xe0, 0xba, 0x03, 0x9b, 0xac, 0xb3, 0xad, 0xce, 0xa8, 0xbf, 0x4e, 0x86, 0x5e, 0x78, 0xc9, 0x39,
	0xf4, 0xa5, 0x2c, 0x31, 0xb4, 0x86, 0x24, 0x08, 0xcd, 0xa1, 0x27, 0x18, 0x1e, 0x64, 0x19, 0xde,
	0xf9, 0xa6, 0xe7, 0x11, 0x5f, 0x1c, 0xa1, 0x37, 0x07, 0xee, 0xc0, 0x65, 0xcb, 0x75, 0xba, 0xe2,
	0xbb, 0x58, 0x87, 0x8a, 0x41, 0x3c, 0x17, 0x21, 0xa8, 0x38, 0xe6, 0x90, 0xb4, 0x94, 0x65, 0xe5,
	0x51, 0xdd, 0x60, 0x6b, 0xbc, 0x0d, 0xd5, 0x3d, 0x77, 0x38, 0xb4, 0x42, 0x74, 0x1f, 0x2a, 0x3e,
	0xf1, 0x5c, 0x46, 0x6d, 0x6c, 0xd6, 0xd7, 0xa8, 0xe1, 0x54, 0xcc, 0x60, 0xdb, 0x68, 0x11, 0x4a,
	0x56, 0xaf, 0x55, 0xa2, 0xa2, 0xbb, 0xd5, 0x0f, 0xff, 0x5a, 0x2a, 0x1d, 0xee, 0x1b, 0x25, 0xab,
	0x87, 0xd7, 0xa0, 0xc6, 0x15, 0x04, 0xe8, 0x21, 0x54, 0xbb, 0x6c, 0xd9, 0x52, 0x96, 0xcb, 0x8f,
	0x1a, 0x9b, 0x0d, 0xa6, 0x83, 0x53, 0x0d, 0x41, 0xc2, 0x3b, 0x00, 0xbb, 0xbe, 0xe9, 0x74, 0x2f,
	0x0e, 0x9d, 0x7e, 0xa1, 0x49, 0x68, 0x09, 0x2a, 0x17, 0xc4, 0xe4, 0x67, 0x65, 0x94, 0x30, 0x02,
	0xde, 0x86, 0x46, 0xa2, 0x22, 0x40, 0x1b, 0xd0, 0xe8, 0xb0, 0xcf, 0x73, 0xcb, 0xe9, 0xbb, 0xe2,
	0xec, 0x79, 0x26, 0x96, 0xb0, 0x19, 0xd0, 0x89, 0xd7, 0x78, 0x1b, 0x2a, 0x07, 0x96, 0x4d, 0x52,
	0x06, 0x2b, 0x63, 0x0c, 0xa6, 0x26, 0x7a, 0x66, 0x78, 0xc1, 0x5d, 0x37, 0xd8, 0x1a, 0xdf, 0x85,
	0xe9, 0x5d, 0xdb, 0xed, 0xbe, 0xa1, 0xc4, 0x0b, 0x33, 0xb8, 0x88, 0xec, 0xa7, 0x6b, 0x7c, 0x0f,
	0xaa, 0x27, 0x9d, 0x1f, 0x49, 0x37, 0x2c, 0xa4, 0x7e, 0x02, 0xe5, 0x33, 0x73, 0x50, 0x78, 0x17,
	0xff, 0x50, 0x40, 0xa5, 0x11, 0x67, 0x91, 0x99, 0x70, 0x1d, 0x5f, 0x42, 0xad, 0xeb, 0x13, 0x33,
	0x24, 0x51, 0x9c, 0xf4, 0x35, 0x9e, 0x1b, 0x6b, 0x51, 0x6e, 0xac, 0x9d, 0x45, 0xc9, 0x63, 0x44,
	0xac, 0xe8, 0x3e, 0x40, 0x60, 0xfd, 0x86, 0x9c, 0x77, 0x2e, 0x43, 0x12, 0xb4, 0xca, 0xcb, 0xca,
	0xa3, 0x8a, 0x51, 0xa7, 0x3b, 0xbb, 0x74, 0x03, 0x3d, 0x06, 0xf0, 0x7c, 0xf7, 0x2d, 0x71, 0x4c,
	0xa7, 0x4b, 0x5a, 0x15, 0x16, 0x48, 0xe9, 0x64, 0x89, 0x88, 0x96, 0xa1, 0xd1, 0x23, 0x41, 0xd7,
	0xb7, 0xbc, 0xd0, 0x72, 0x9d, 0xd6, 0x34, 0x73, 0x43, 0xde, 0xc2, 0x5b, 0x50, 0x8f, 0x9c, 0x09,
	0xd0, 0x2a, 0xd4, 0xa9, 0xd9, 0xf2, 0x0d, 0xcd, 0xc6, 0x8a, 0xd9, 0xfd, 0xa8, 0xbe, 0x58, 0xe1,
	0xbf, 0x95, 0x00, 0xf8, 0x1d, 0xb0, 0x40, 0x5c, 0xeb, 0x92, 0x36, 0x60, 0xd6, 0x33, 0x7d, 0xe2,
	0x84, 0xe7, 0x82, 0xb7, 0x20, 0x79, 0x66, 0x38, 0x87, 0x48, 0xf7, 0x2f, 0xa1, 0x16, 0x84, 0xa6,
	0x4f, 0x03, 0x58, 0x9e, 0x1c, 0x40, 0xc1, 0x8a, 0x7e, 0x01, 0x6a, 0xdf, 0x72, 0xac, 0xe0, 0x82,
	0xf4, 0x5a, 0x95, 0x89, 0x62, 0x31, 0x6f, 0x26, 0xf0, 0xd3, 0xd9, 0xc0, 0x7f, 0x9e, 0x0a, 0x7c,
	0x35, 0x5f, 0x3d, 0x72, 0xe8, 0x97, 0xa0, 0x12, 0xfa, 0x84, 0xb4, 0x6a, 0x92, 0x8b, 0x3c, 0xe1,
	0x0c, 0x46, 0xa0, 0xf5, 0x91, 0xc4, 0x8f, 0xd5, 0x07, 0x0f, 0x4a, 0xbe, 0x3e, 0x12, 0x36, 0x03,
	0xba, 0xf1, 0x9a, 0x25, 0x22, 0x2d, 0x90, 0x28, 0x11, 0xfb, 0x96, 0x4d, 0x52, 0x89, 0x48, 0x89,
	0x06, 0xdb, 0xa6, 0x37, 0x4b, 0xff, 0x9e, 0x87, 0x97, 0x1e, 0x61, 0x51, 0x9f, 0x13, 0x37, 0x4b,
	0x79, 0xce, 0x2e, 0x3d, 0x42, 0xa3, 0xc0, 0x57, 0x93, 0xd2, 0x4f, 0x07, 0xb5, 0x7b, 0x61, 0xd9,
	0x3d, 0x9f, 0x38, 0x2c, 0x06, 0x75, 0x23, 0xfe, 0x8e, 0x4b, 0x89, 0x3a, 0x3d, 0xc3, 0x4b, 0x09,
	0x7d, 0x06, 0x35, 0x97, 0xf9, 0x1d, 0xb4, 0x54, 0x29, 0x64, 0x22, 0x16, 0x11, 0x8d, 0x26, 0x62,
	0xe4, 0x4c, 0x10, 0x9b, 0x9b, 0x4b, 0xc4, 0x88, 0x85, 0x9b, 0xcb, 0xc2, 0xb0, 0x05, 0x75, 0x6a,
	0x98, 0x61, 0x3a, 0x03, 0x82, 0x9a, 0x30, 0x6d, 0xbb, 0xef, 0x88, 0xcf, 0xe2, 0x50, 0x31, 0xf8,
	0x07, 0xdd, 0x1d, 0xd1, 0x06, 0xcc, 0x3c, 0xaf, 0x18, 0xfc, 0x03, 0x1b, 0xa0, 0xb2, 0xf6, 0x60,
	0x90, 0x3e, 0x5a, 0x86, 0xe9, 0x0e, 0x5d, 0x8b, 0xf8, 0x01, 0xef, 0x4b, 0x8c, 0xca, 0x09, 0x68,
	0x05, 0xa6, 0x7d, 0x7a, 0x84, 0xc8, 0xd9, 0x39, 0xce, 0x11, 0x1d, 0x6c, 0x70, 0x22, 0xfe, 0x01,
	0x80, 0x3b, 0x16, 0x15, 0x05, 0x77, 0x2f, 0x55, 0x14, 0xc2, 0x73, 0x41, 0xa2, 0xbe, 0xb2, 0x13,
	0xce, 0x7d, 0xd2, 0x17, 0xca, 0x67, 0xa5, 0xe3, 0x49, 0xdf, 0x50, 0x3b, 0x62, 0x85, 0xff, 0xac,
	0xc0, 0xc2, 0x1e, 0xeb, 0x12, 0xac, 0xd4, 0xc9, 0x4f, 0x23, 0x12, 0x4c, 0x9c, 0x09, 0xe9, 0x7e,
	0x51, 0xba, 0x41, 0xbf, 0x28, 0xe7, 0xfa, 0x05, 0x5a, 0x84, 0xea, 0xc8, 0xeb, 0x99, 0x21, 0x61,
	0x85, 0xa5, 0x1a, 0xe2, 0x0b, 0x3f, 0x01, 0x74, 0xe8, 0x04, 0x1e, 0x75, 0xec, 0xda, 0x96, 0xe1,
	0x17, 0x30, 0x7f, 0x64, 0x05, 0x29, 0x89, 0xb4, 0xb1, 0xca, 0x15, 0xc6, 0xe2, 0x5f, 0xc3, 0xc2,
	0x3e, 0xb1, 0xc9, 0x8d, 0x62, 0xd1, 0x84, 0xe9, 0xbe, 0xeb, 0x77, 0xf9, 0x2d, 0xaa, 0x06, 0xff,
	0x40, 0x1a, 0x94, 0x4d, 0xdb, 0x66, 0xee, 0xaa, 0x06, 0x5d, 0xe2, 0xdf, 0x01, 0x3a, 0xa5, 0xcd,
	0x44, 0x14, 0xb6, 0x50, 0xfe, 0x10, 0xaa, 0xbc, 0x3b, 0x15, 0x36, 0x39, 0x4e, 0xca, 0x74, 0x89,
	0xd2, 0xd5, 0x5d, 0x62, 0x11, 0xaa, 0x7c, 0xe2, 0x89, 0x58, 0x8b, 0x2f, 0xfc, 0x57, 0x05, 0xd0,
	0xee, 0xc8, 0xb2, 0x7b, 0xff, 0x6f, 0x03, 0xa2, 0x36, 0x55, 0x1e, 0xd3, 0xa6, 0x24, 0x0b, 0x2b,
	0x29, 0x0b, 0x9f, 0xc1, 0xad, 0x03, 0xd6, 0x37, 0x73, 0x16, 0x4e, 0x9c, 0x03, 0xf8, 0x39, 0x34,
	0x45, 0xb2, 0x7c, 0x84, 0xf0, 0x1f, 0x15, 0x58, 0xa0, 0x59, 0x93, 0x16, 0x9d, 0x70, 0xef, 0x4b,
	0x50, 0xe9, 0xfb, 0xee, 0xb0, 0x10, 0xad, 0x50, 0x02, 0xba, 0x0b, 0xa5, 0xd0, 0x4d, 0x45, 0x41,
	0x90, 0x4b, 0x21, 0x45, 0x55, 0x55, 0x67, 0x34, 0xec, 0x10, 0x9f, 0xc5, 0xa0, 0x62, 0x88, 0x2f,
	0xbc, 0xc9, 0x2d, 0xe1, 0xf8, 0xe5, 0x9a, 0x39, 0x7f, 0x02, 0xda, 0x29, 0xc9, 0x88, 0x5c, 0x6b,
	0x78, 0x26, 0x17, 0x51, 0x4a, 0x5d, 0xc4, 0x11, 0xdc, 0xe2, 0x65, 0x70, 0x13, 0x33, 0xc6, 0x6a,
	0x7b, 0x16, 0x69, 0xfb, 0x88, 0x9b, 0x31, 0x01, 0x1d, 0xd8, 0xa3, 0x6c, 0x46, 0x7c, 0x06, 0x35,
	0x4e, 0x0f, 0x8a, 0x00, 0x67, 0x44, 0x43, 0x2b, 0xa0, 0x86, 0xee, 0x39, 0xb5, 0x2d, 0xc8, 0xf7,
	0xa8, 0x5a, 0xe8, 0xd2, 0xbf, 0x01, 0xf6, 0x60, 0xf1, 0x74, 0xd4, 0xa1, 0xed, 0xa8, 0x43, 0x6e,
	0x94, 0x00, 0x63, 0xfc, 0x8d, 0x13, 0xa3, 0x3c, 0x26, 0x31, 0xf0, 0x4f, 0x30, 0xf7, 0x8a, 0x84,
	0x6c, 0x94, 0x26, 0x27, 0x5d, 0x35, 0x6a, 0x3f, 0x85, 0x19, 0xb7, 0xdf, 0x0f, 0x48, 0x28, 0x06,
	0x28, 0x3d, 0xaf, 0x6c, 0x34, 0xf8, 0x1e, 0x1f, 0xa1, 0xf9, 0x09, 0x5b, 0x96, 0x26, 0x2c, 0xfe,
	0x7d, 0x09, 0xe6, 0x5e, 0x8f, 0x6e, 0x72, 0x66, 0x13, 0xa6, 0xdf, 0x9a, 0xf6, 0x88, 0x97, 0xf1,
	0x8c, 0xc1, 0x3f, 0x68, 0x5b, 0x1b, 0xf9, 0xb6, 0x40, 0x7d, 0x74, 0x89, 0xee, 0x51, 0x80, 0xd7,
	0x1d, 0xf9, 0x81, 0xf5, 0x96, 0x02, 0x18, 0xda, 0xee, 0x92, 0x0d, 0xf4, 0x05, 0xd4, 0x7b, 0xc4,
	0xb6, 0x86, 0x56, 0x48, 0x7c, 0x36, 0xc2, 0xe7, 0xc4, 0x98, 0xdb, 0x8f, 0x76, 0x8d, 0x84, 0x01,
	0x7d, 0x01, 0x28, 0x34, 0xfd, 0x01, 0x09, 0xcf, 0xd9, 0xa8, 0xee, 0x99, 0xe1, 0x68, 0x48, 0x47,
	0x3c, 0x75, 0x46, 0xe3, 0x14, 0x6a, 0xe1, 0x3e, 0xdb, 0x47, 0xab, 0xb0, 0x20, 0x73, 0x73, 0xcf,
	0xeb, 0x8c, 0x79, 0x3e, 0x61, 0x66, 0xfe, 0x7f, 0x53, 0x51, 0x4b, 0x5a, 0x59, 0x9a, 0x28, 0xd7,
	0x0f, 0x04, 0xde, 0xe0, 0x13, 0xe5, 0x06, 0x12, 0xaf, 0x61, 0xfe, 0x95, 0xed, 0x76, 0x64, 0x89,
	0x6b, 0x95, 0x63, 0x0b, 0x6a, 0x9e, 0x19, 0x86, 0xc4, 0x77, 0x44, 0x46, 0x45, 0x9f, 0xf8, 0x07,
	0x98, 0xdf, 0xb7, 0xfa, 0x7d, 0x59, 0xe3, 0x0a, 0xa8, 0x0e, 0x79, 0x77, 0x5e, 0x6c, 0x47, 0xcd,
	0x21, 0xef, 0xd8, 0x43, 0x67, 0x05, 0x54, 0xd7, 0xee, 0x71, 0xae, 0x52, 0x8e, 0xcb, 0xb5, 0x7b,
	0x74, 0x81, 0x7f, 0x04, 0x2d, 0x51, 0x1f, 0x78, 0xae, 0x13, 0x30, 0x78, 0x17, 0xe9, 0x0f, 0xc6,
	0xe0, 0x25, 0x71, 0x08, 0xc3, 0x56, 0xd1, 0x29, 0x51, 0xa5, 0x65, 0x79, 0xc5, 0x51, 0x01, 0x6d,
	0x70, 0xbc, 0x1b, 0xdc, 0x20, 0xa0, 0x07, 0xa0, 0xbd, 0x1e, 0x85, 0x62, 0x86, 0x08, 0x91, 0x38,
	0x3f, 0x15, 0x39, 0x3f, 0xef, 0x41, 0x25, 0x34, 0x07, 0x91, 0x11, 0x2a, 0x53, 0x74, 0x66, 0x0e,
	0x0c, 0xb6, 0x8b, 0x7f, 0x0b, 0x0b, 0xaf, 0x88, 0xd0, 0x13, 0x48, 0xcd, 0x24, 0x02, 0x93, 0xca,
	0x78, 0x30, 0x59, 0x58, 0x83, 0x95, 0x49, 0x35, 0x28, 0xa3, 0x5c, 0xfc, 0x1d, 0x68, 0x67, 0xe6,
	0x20, 0xed, 0xc5, 0xb5, 0xe0, 0xdc, 0xd5, 0x4e, 0x35, 0x01, 0xd1, 0xfc, 0x4c, 0x7b, 0x85, 0x4f,
	0x78, 0xd6, 0x9e, 0x99, 0x83, 0xd8, 0xd1, 0x45, 0xa8, 0x7a, 0x3e, 0xe9, 0x5b, 0xef, 0xc5, 0xdb,
	0x53, 0x7c, 0xa1, 0x15, 0x98, 0xb5, 0x9c, 0xae, 0x3d, 0xea, 0x11, 0xae, 0x43, 0x00, 0x99, 0xf4,
	0x26, 0x3e, 0x04, 0x2d, 0x51, 0x28, 0x72, 0x44, 0x83, 0x72, 0x68, 0x0e, 0x84, 0x3a, 0xba, 0x94,
	0xfc, 0x29, 0x8d, 0xf5, 0x07, 0xbf, 0x84, 0x26, 0x4f, 0x81, 0x8f, 0xba, 0x09, 0x7c, 0x07, 0x6e,
	0x67, 0xc4, 0xb9, 0x39, 0xf8, 0x67, 0x51, 0x6a, 0xc9, 0x5e, 0x23, 0x11, 0x3c, 0x85, 0xbd, 0x2b,
	0xe2, 0x90, 0xc9, 0x8c, 0x42, 0xfc, 0x29, 0xa0, 0xbd, 0x0b, 0xd2, 0x7d, 0x73, 0xf3, 0x1b, 0xc2,
	0x3f, 0x87, 0x5b, 0x29, 0x51, 0x11, 0x9f, 0x45, 0xa8, 0x92, 0xf7, 0x56, 0xc0, 0xfc, 0x61, 0xc8,
	0x96, 0x7f, 0xe1, 0x3f, 0x94, 0xa0, 0x11, 0x61, 0xfa, 0x1e, 0x79, 0x8f, 0xb6, 0xb2, 0x8e, 0xdf,
	0x97, 0x0e, 0x61, 0x2c, 0x62, 0x1d, 0xb4, 0x9d, 0xd0, 0xbf, 0x4c, 0x92, 0x72, 0x2d, 0x95, 0x19,
	0x7a, 0x4e, 0x8a, 0xfa, 0xc7, 0x45, 0x18, 0x9f, 0x7e, 0x08, 0x33, 0xb2, 0x22, 0x7a, 0x81, 0x6f,
	0xc8, 0x65, 0x74, 0x81, 0x6f, 0xc8, 0x25, 0x7a, 0x18, 0x95, 0x55, 0xe1, 0xb3, 0x81, 0xd3, 0x9e,
	0x95, 0xbe, 0x56, 0xf4, 0x7d, 0xa8, 0xc7, 0xda, 0x0b, 0xf4, 0x7c, 0x9a, 0xd6, 0x93, 0x8a, 0x5a,
	0xa2, 0x65, 0xf5, 0x73, 0xfe, 0xde, 0x64, 0x8f, 0xc4, 0x19, 0x50, 0x8d, 0xf6, 0x69, 0xdb, 0xf8,
	0xbe, 0xbd, 0xaf, 0x4d, 0x21, 0x15, 0x2a, 0x07, 0x87, 0x47, 0x6d, 0x4d, 0x41, 0x35, 0x28, 0xef,
	0x1f, 0x1a, 0x5a, 0x69, 0xf5, 0x31, 0xd4, 0xe3, 0xb1, 0x41, 0xe9, 0xc7, 0x27, 0xc7, 0x6d, 0xce,
	0xf9, 0xcd, 0xe9, 0xc9, 0xb1, 0xa6, 0xd0, 0xd5, 0xd1, 0xe1, 0x71, 0x5b, 0x2b, 0xad, 0x1e, 0xc1,
	0x4c, 0xd4, 0xb4, 0xbf, 0x75, 0x7b, 0x04, 0xdd, 0x4a, 0x9a, 0xf8, 0xf9, 0xf1, 0x89, 0xf1, 0xed,
	0xce, 0x91, 0x36, 0x85, 0x16, 0x60, 0x36, 0xde, 0x3c, 0xd8, 0x39, 0x3d, 0xd3, 0x14, 0xd4, 0xe4,
	0x59, 0xce, 0xb6, 0x8c, 0xf6, 0xde, 0x77, 0xc6, 0x69, 0x5b, 0x2b, 0x6d, 0xfe, 0x17, 0xa0, 0xbc,
	0xf3, 0xfa, 0x10, 0xfd, 0x12, 0x20, 0x79, 0x2a, 0xa1, 0x45, 0xde, 0xc3, 0xb3, 0x6f, 0x27, 0x7d,
	0x31, 0xf7, 0xc3, 0x40, 0x7b, 0xe8, 0x85, 0x97, 0x78, 0x0a, 0x6d, 0x41, 0x43, 0x7a, 0xd1, 0xa0,
	0x3b, 0x4c, 0x41, 0xfe, 0x8d, 0xa3, 0xa7, 0x7f, 0x21, 0xc1, 0x53, 0x68, 0x13, 0xd4, 0xe8, 0x55,
	0x83, 0x9a, 0x8c, 0x98, 0x79, 0xe4, 0xe8, 0x73, 0x29, 0x91, 0x00, 0x4f, 0x51, 0x63, 0x93, 0xb7,
	0x8c, 0x30, 0x36, 0xf7, 0xb8, 0xb9, 0xc2, 0xd8, 0xaf, 0xa0, 0x21, 0xbd, 0x57, 0x84, 0xb1, 0xf9,
	0x17, 0x8c, 0x2e, 0x8f, 0x32, 0x3c, 0x85, 0x76, 0x61, 0x46, 0x06, 0xf1, 0xa8, 0x25, 0x9a, 0x79,
	0x0e, 0xd7, 0x5f, 0x71, 0xf4, 0x4b, 0x98, 0x4d, 0x81, 0x79, 0xf4, 0x89, 0x1c, 0xa9, 0xb4, 0x96,
	0xec, 0xef, 0x19, 0x78, 0x0a, 0x7d, 0x0d, 0x90, 0xa0, 0x79, 0xe1, 0x79, 0x0e, 0xde, 0xeb, 0x5a,
	0x46, 0x30, 0xe0, 0xc6, 0xcb, 0x50, 0x55, 0x18, 0x5f, 0x80, 0x5e, 0xaf, 0x30, 0xfe, 0x39, 0x34,
	0x24, 0xc8, 0x2a, 0xe2, 0x96, 0x07, 0xb1, 0x05, 0x86, 0x6f, 0x28, 0x68, 0x0f, 0xe6, 0x33, 0x60,
	0x14, 0xdd, 0xe5, 0x81, 0x2f, 0x84, 0xa8, 0xc5, 0x4a, 0xbe, 0x82, 0x86, 0xf4, 0xd0, 0x13, 0x16,
	0xe4, 0x9f, 0x7e, 0xd9, 0x9b, 0x13, 0x61, 0xe3, 0x98, 0x5f, 0x0a, 0x5b, 0xea, 0x11, 0x20, 0xc2,
	0x26, 0xfd, 0x0c, 0x8b, 0xa7, 0xd0, 0x0b, 0xa8, 0xc7, 0x0f, 0x10, 0x74, 0x9b, 0xdb, 0x9b, 0x79,
	0x90, 0x5c, 0x11, 0xb0, 0x38, 0xe8, 0x42, 0x81, 0x1c, 0xf4, 0xeb, 0xea, 0x78, 0x06, 0x35, 0x01,
	0x6f, 0xd1, 0x2d, 0x26, 0x9e, 0x06, 0xbb, 0xe3, 0x25, 0x1f, 0x29, 0x68, 0x1b, 0x6a, 0x02, 0x8e,
	0x0b, 0xd9, 0x34, 0x38, 0xd7, 0xef, 0xe6, 0x64, 0xd9, 0x3c, 0xff, 0x9e, 0x36, 0x31, 0x16, 0xef,
	0xa4, 0xac, 0x99, 0x92, 0x54, 0x59, 0xcb, 0x8a, 0xd2, 0x98, 0x28, 0x29, 0x6b, 0x26, 0x95, 0x94,
	0xb5, 0x2c, 0x32, 0x97, 0x12, 0x09, 0xb8, 0x4c, 0x04, 0x2e, 0x85, 0x4c, 0x06, 0x6b, 0x16, 0xc8,
	0x3c, 0x05, 0x35, 0xc2, 0x77, 0x42, 0x26, 0x83, 0x26, 0xf5, 0xdb, 0x99, 0x5d, 0x31, 0x12, 0xa5,
	0x2e, 0xc2, 0x84, 0xe5, 0x2e, 0x72, 0xad, 0xf0, 0xa2, 0x97, 0xac, 0x67, 0x93, 0x90, 0xec, 0xd8,
	0x36, 0x1a, 0xc3, 0x36, 0x5e, 0x7c, 0xf3, 0x4f, 0x55, 0xa8, 0xf3, 0xa9, 0x41, 0xfb, 0xef, 0x13,
	0xa8, 0xc7, 0x38, 0x50, 0xe4, 0x59, 0x16, 0x17, 0xea, 0xf2, 0xa4, 0x61, 0xd7, 0xfb, 0x14, 0xea,
	0x31, 0xe8, 0x43, 0x32, 0x75, 0xf2, 0xc5, 0xb6, 0x01, 0x12, 0xbc, 0x28, 0x9c, 0xcf, 0x01, 0xc8,
	0xc9, 0x6a, 0x5e, 0xb0, 0x51, 0x99, 0x32, 0x3b, 0x0b, 0x04, 0xaf, 0x88, 0xe0, 0x7a, 0xdc, 0x0c,
	0x8b, 0x7c, 0x98, 0x4f, 0xcd, 0x7c, 0x96, 0x55, 0xbb, 0xd0, 0x90, 0xc0, 0x88, 0x48, 0xc7, 0x3c,
	0xb2, 0xd1, 0x5b, 0x79, 0x42, 0x7c, 0xed, 0x5b, 0xd0, 0x90, 0x40, 0xa5, 0xd0, 0x91, 0x87, 0x99,
	0x99, 0x68, 0x6f, 0x28, 0xe8, 0x57, 0x30, 0x9b, 0x02, 0x67, 0xa2, 0x75, 0x17, 0xe1, 0x3d, 0x5d,
	0x2f, 0x22, 0xc5, 0x26, 0x3c, 0x81, 0xea, 0x2b, 0x42, 0xf1, 0x26, 0x8a, 0x11, 0xef, 0xe4, 0x50,
	0x3f, 0x06, 0x10, 0xc1, 0x4a, 0x0b, 0x16, 0x84, 0xe9, 0x39, 0x2f, 0x3e, 0x0a, 0x62, 0xa4, 0xe2,
	0x93, 0xa0, 0xa3, 0x28, 0x8a, 0x2c, 0xea, 0x65, 0xe7, 0x6c, 0x47, 0x65, 0xc1, 0xc4, 0xe5, 0xb2,
	0x90, 0x15, 0xdc, 0xc9, 0xed, 0xc7, 0xde, 0x3d, 0x67, 0xff, 0x7b, 0xe6, 0x99, 0xdd, 0xf0, 0xe6,
	0x55, 0xb1, 0xab, 0xfd, 0xfd, 0xc3, 0x03, 0xe5, 0x9f, 0x1f, 0x1e, 0x28, 0xff, 0xfe, 0xf0, 0x40,
	0xf9, 0xcb, 0x7f, 0x1e, 0x4c, 0x75, 0xaa, 0x8c, 0xe7, 0xc9, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x11, 0x23, 0xf6, 0x3b, 0x81, 0x1c, 0x00, 0x00,
}
